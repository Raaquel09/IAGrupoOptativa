<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Communication Optimal Unbalanced Private Set Union</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2024-02-26">26 Feb 2024</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jean-Guillaume</forename><surname>Dumas</surname></persName>
							<email>guillaume.dumas@univ-grenoble-alpes.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">LJK</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5224</orgName>
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Grenoble INP</orgName>
								<address>
									<postCode>38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexis</forename><surname>Galan</surname></persName>
							<email>alexis.galan@univ-grenoble-alpes.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">LJK</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5224</orgName>
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Grenoble INP</orgName>
								<address>
									<postCode>38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bruno</forename><surname>Grenet</surname></persName>
							<email>bruno.grenet@univ-grenoble-alpes.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">LJK</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5224</orgName>
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Grenoble INP</orgName>
								<address>
									<postCode>38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">A</forename><surname>Maignan</surname></persName>
							<email>aude.maignan@univ-grenoble-alpes.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">LJK</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5224</orgName>
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Grenoble INP</orgName>
								<address>
									<postCode>38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><forename type="middle">S</forename><surname>Roche</surname></persName>
							<email>roche@usna.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">LJK</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5224</orgName>
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Grenoble INP</orgName>
								<address>
									<postCode>38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">United States Naval Academy</orgName>
								<address>
									<settlement>Annapolis</settlement>
									<region>Maryland</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Communication Optimal Unbalanced Private Set Union</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2024-02-26">26 Feb 2024</date>
						</imprint>
					</monogr>
					<idno type="MD5">59C74B7F3C94C00827D2EF4D1FC1530B</idno>
					<idno type="arXiv">arXiv:2402.16393v1[cs.CR]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2024-03-06T22:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the private set union (PSU) problem, where two parties each hold a private set of elements, and they want one of the parties (the receiver) to learn the union of the two sets and nothing else. Our protocols are targeted for the unbalanced case where the receiver's set size is larger than the sender's set size, with the goal of minimizing the costs for the sender both in terms of communication volume and local computation time. This setting is motivated by applications where the receiver has significantly more data (input set size) and computational resources than the sender which might be realized on a small, low-power device. Asymptotically, we achieve communication cost linear in the sender's (smaller) set size, and computation costs for sender and receiver which are nearly-linear in their respective set sizes. To our knowledge, ours is the first algorithm to achieve nearly-linear communication and computation for PSU in this unbalanced setting. Our protocols utilize fully homomorphic encryption (FHE) and, optionally, linearly homomorphic encryption (LHE) to perform the necessary computations while preserving privacy. The underlying computations are based on univariate polynomial arithmetic realized within homomorphic encryption, namely fast multiplication, modular reduction, and multi-point evaluation. These asymptotically fast HE polynomial arithmetic algorithms may be of independent interest.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A Private Set Union (PSU) protocol is a cryptographic protocol involving two parties, in which a receiver, denoted R, owns a set X, and a sender, denoted S, owns a set Y. The functionality desired from such a protocols is denoted F P SU and is presented in Func. 1: the receiver R receives the union X∪Y. The protocol is parameterized on (upper bounds on) the set sizes |X| and |Y |, which are therefore implicitly revealed to both parties as well. However, the sender S learns nothing about the contents of X.</p><p>We are interested in the case of unbalanced inputs, where the sender and receiver set sizes may be (vastly) different, and on minimizing the communication volume between the two parties. Note that it is impossible Functionality 1:</p><formula xml:id="formula_0">F P SU , Private Set Union R X → X ∪ Y ← PSU Protocol ← Y</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S</head><p>to reduce the communication size below that of the sender's set, since in the worst case this entire set must be revealed to the receiver, and the sender must not know how many elements were actually revealed.</p><p>The more difficult situation for unbalanced sets is therefore when the sender's set size is smaller than the receiver's, and we may hope to have sub-linear worst-case communication costs; this is the focus of our work.</p><p>More precisely, if we define m and n to be respectively the sizes of the sender's and receiver's sets, we will assume n ≥ m in our setting, and our goal is to develop a PSU protocol with O(m) communication (which we can achieve) and O(m) and O(n) computation resp. for the sender and receiver (which we can nearly achieve).</p><p>The recent surge in research for efficient PSU protocols is motivated by numerous practical applications. One example which is motivating for our unbalanced setting with larger receiver is secure aggregation as in <ref type="bibr" target="#b25">[Ramanathan et al.(2020)</ref>]: A single server maintains a growing list, and individual contributors periodically interact with the server to add their elements into the list. If the collected list may be sensitive, such as individuals who may have been exposed to some communicable disease, then the server may not want to reveal the list to every contributor; similarly, the contributors may not wish to reveal their entries which are already on the list to avoid potential inferences on relationships between the contributors themselves. Our UPSU <ref type="bibr" target="#b7">[Frikken(2007)</ref>]</p><p>[ <ref type="bibr" target="#b6">Davidson and Cid(2017)</ref>] <ref type="bibr" target="#b31">[Zhang et al.(2023)</ref>] <ref type="bibr" target="#b30">[Tu et al.(2023)</ref>]</p><formula xml:id="formula_1">Arith. cost for R O n 1+ϵ O (n) O (n) O (n) O n 1+ϵ Arith. cost for S O (nm) O (m) O (m log n) O m 2 O m 1+ϵ Comm. volume O (n) O (n) O (n) O (m log n) O(m) Deterministic ✓ ✗ ✓ ✗ ✓</formula><p>Previous work. Privacy-preserving set operations have traditionally started with private set intersection (PSI), which has seen a number of recent efficient protocols and important applications such as private contact discovery <ref type="bibr" target="#b17">[Kiss et al.(2017)</ref>, <ref type="bibr" target="#b12">Groce et al.(2019)</ref>, <ref type="bibr" target="#b28">Resende and de Freitas Aranha(2021)</ref>, <ref type="bibr" target="#b11">Gordon et al.(2022)</ref>, <ref type="bibr" target="#b0">Badrinarayanan et al.(2022)</ref>, <ref type="bibr" target="#b23">Morales et al.(2023)</ref>].</p><p>Private set union protocols have also garnered significant recent interest <ref type="bibr" target="#b4">[Brickell and Shmatikov(2005)</ref>, <ref type="bibr" target="#b18">Kissner and Song(2005)</ref>, <ref type="bibr" target="#b7">Frikken(2007)</ref>, <ref type="bibr" target="#b6">Davidson and Cid(2017)</ref>, <ref type="bibr" target="#b19">Kolesnikov et al.(2019)</ref>, <ref type="bibr" target="#b9">Garimella et al.(2021)</ref>, <ref type="bibr" target="#b17">Jia et al.(2022)</ref>, <ref type="bibr" target="#b31">Zhang et al.(2023)</ref>, <ref type="bibr" target="#b30">Tu et al.(2023)</ref>]. We mention a few results most closely related to the current work.</p><p>Frikken's PSU algorithm <ref type="bibr" target="#b7">[Frikken(2007)</ref>] represents a set as a polynomial, whose roots are the set elements.</p><p>Then, the elements of the sender that are not roots of the receiver's polynomial, are exactly the elements that must be exchanged. This protocol requires a polynomial evaluation on the receiver's polynomial in all the sender's elements, and the receiver should learn nothing from a root but should retrieve the evaluated elements from a non zero. The Paillier linearly homomorphic (LHE) scheme is used to keep the receiver's set private.</p><p>Instead of using polynomials and its zeroes, <ref type="bibr" target="#b6">Davidson and Cid [Davidson and Cid(2017)</ref>] proposed a version using Bloom filters and its zeroes, also LHE encrypted, in order to hide the receiver's set. This improves asymptotically on on Frikken's protocol, but the usage of Bloom filters makes it non deterministic.</p><p>In <ref type="bibr" target="#b31">[Zhang et al.(2023)</ref>], Zhang et al. imagined a version divided in two sub-protocols. The first one, called multi-query reverse private membership test, gives to the receiver a bit-vector where the zeroes represent the elements of the sender that are not in the receiver's set. The second sub-protocol is an oblivious transfer (OT) where the bit-vector represent the choice-bits. All those protocols where not designed for an unbalanced situation and their communication volume is always proportional to the size of the receiver's set.</p><p>To our knowledge, the best private set union protocol specially designed for the unbalanced situation comes from <ref type="bibr" target="#b30">[Tu et al.(2023)</ref>] where Tu et al. proposed a protocol using many different techniques (set hashing, windowing, baby-set-giant-step precomputation matrix, fully homomorphic encryption scheme (FHE), oblivious transfer...) in order to reduce the communication volume to a logarithmic dependency in the size of the receiver's set. The usage of Cuckoo hashing makes this protocol non-deterministic as well.</p><p>Our contributions. We present two new (related) protocols for unbalanced PSU (thus UPSU), first a generic one, and then an instantiation of it:</p><p>• Our generic UPSU protocol is in two parts and relies on efficient polynomial arithmetic algorithms, such as polynomial remainder and polynomial multipoint evaluation, that applied over FHE and LHE schemes. This protocol requires that the plaintext spaces of the FHE and LHE are compatible.</p><p>• We show that an instantiation of our protocol is possible with the BGV cryptosytem used separately for both parts, as both FHE and LHE.</p><p>The security of our protocol is proved in the semi-honest setting, and our complexity analysis is in the arithmetic setting (equivalently, assuming that all input elements are constant-sized).</p><p>Table <ref type="table" target="#tab_0">1</ref> summarizes the cost analysis of the previously mentioned protocols in an unbalanced situation: the receiver R owns a set of size n, the sender S owns a set of size m with n ≥ m. In the table, the "Comm. volume" row represents a bound on the quantity of elements exchanged, and the "Arith. cost" rows represent a bound on the number of basic arithmetic operations done by each party. A value colored in green is a value satisfying our goals, which are an arithmetic cost for the sender and a communication volume independent of the size of the receiver's (larger) set and a deterministic algorithm. Orange and red values are used to denote larger dependencies, that is, logarithmic, or more, respectively, in the size of the larger set.</p><p>Outline. In Section 2, we present the blocks needed to build our protocols, including our algorithms for polynomial arithmetic over LHE and FHE. Section 3 defines the security expected from our protocols and lists the security assumptions we are making. Our unbalanced PSU, using generic LHE and FHE schemes, in presented, proven correct and secure under honest-but-curious adversary model and analyzed in term of its asymptotics in Section 4. We show that we can instantiate this protocol, with the BGV cryptosystem both as LHE and FHE, and we compare our simulated communication volume to <ref type="bibr" target="#b30">[Tu et al.(2023)</ref>] in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Building Blocks</head><p>In this section, we present our main building blocks based on polynomial arithmetic. We show that we can perform efficient polynomial arithmetic homomorphically. We distinguish between tasks that require a fully homomorphic encryption scheme and those who can be implemented within a linearly homomorphic encryption scheme. Since it has an important impact on the practical efficiency, we also study the multiplicative depth of these algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Cryptographic tools</head><p>We first introduce the main crytographic tools our protocol is based on, namely Linearly and Fully Homomorphic Encryption Schemes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Homomorphic Encryption Scheme (LHE)</head><p>For our purposes<ref type="foot" target="#foot_0">1</ref> , a linearly homomorphic encryption (LHE) scheme consists of five algorithms (L.Setup, L.E, L.D, + L , ⋉ L ) :</p><p>• (pk, sk) ← L.Setup(κ): Given a security parameter κ, outputs a pair of secret and public keys (pk, sk). pk implicitly defines a ring M, which is the plaintext space, and a ciphertext space E;</p><p>• c ← L.E pk (m): Given as inputs a plaintext m ∈ M and a public key pk, outputs a ciphertext c ∈ E;</p><p>• m ← L.D sk (c): Given as inputs a ciphertext c ∈ E and a public key sk, outputs a plaintext m ∈ M; </p><formula xml:id="formula_2">• c 3 ← c 1 + L c 2 : Given as inputs two ciphertexts c 1 , c 2 ∈ E, outputs a ciphertext c 3 ∈ E; • c 3 ← m 1 ⋉ L c 2 : Given as inputs a plaintext m 1 ∈ M and a ciphertext c 2 ∈ E, outputs a ciphertext c 3 ∈ E. Definition 1. (L.Setup, L.E, L.D, + L , ⋉ L )</formula><formula xml:id="formula_3">L.D sk (L.E pk (m)) = m, (1) L.D sk (L.E pk (m 1 ) + L L.E pk (m 2 )) = m 1 + m 2 , (2) L.D sk (m 1 ⋉ L L.E pk (m 2 )) = m 1 m 2 .</formula><p>(3)</p><p>ii) Security. The scheme is semantically secure if it is not possible to derive from a ciphertext more than negligible information on the plaintext.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Fully Homomorphic Encryption Scheme (FHE)</head><p>A fully homomorphic encryption (FHE) scheme consists of six algorithms</p><formula xml:id="formula_4">(F.Setup, F.E, F.D, + F , ⋉ F , × F ) (4)</formula><p>where (F.Setup, F.E, F.D, + F , ⋉ F ) is a LHE and the algorithm × F is as follows: </p><formula xml:id="formula_5">• c 3 ← c 1 × F c 2 : Given as inputs two ciphertexts c 1 , c 2 ∈ E,</formula><formula xml:id="formula_6">F.D sk (F.E pk (m 1 ) × F F.E pk (m 2 )) = m 1 m 2 .</formula><p>(5)</p><p>ii) Security. The scheme is semantically secure if it is not possible to derive from a ciphertext more than negligible information on the plaintext.</p><p>Remark 3. We extend the encryption and decryption algorithms for a LHE or a FHE to allow vectors as inputs:</p><formula xml:id="formula_7">if v ∈ M n , L.E pk (v) (resp. F.E pk (v)) outputs c ∈ E n such that c i is the encryption for v i for 1 ≤ i ≤ n. Similarly, L.D sk (c) (resp. F.D sk (c)) outputs v.</formula><p>In the same way, we extend these algorithms to polynomial inputs and outputs in M[X] or E[X] by stating that the encryption of a polynomial is the encryption of its vector of coefficients.</p><p>This allows for instance to extend the algorithm + L (resp. + F ) to vectors or polynomials. Also, we can extend ⋉ L (resp. ⋉ F ) to a matrix-vector product where the matrix is in clear and the vector encrypted:</p><formula xml:id="formula_8">   v 11 • • • v 1n . . . . . . v m1 • • • v mn    ⋉ L    c 1 . . . c n    =    v 11 ⋉ L c 1 + L • • • + L v 1n ⋉ L c n . . . v m1 ⋉ L c 1 + L • • • + L v mn ⋉ L c n   <label>(6)</label></formula><p>The resulting algorithm has multiplicative depth 1.</p><p>Notations Since we use both a LHE scheme and a FHE scheme, for clarity, we will denote with x a variable which is encrypted under a LHE scheme, and with x a variable which is encrypted under a FHE scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Linearly homomorphic polynomial arithmetic</head><p>In this section, we focus on polynomial operations than can be performed linearly homomorphically, when one of the inputs is in clear.</p><p>As customary in polynomial arithmetic, the homomorphic algorithms we describe reduce to polynomial multiplications. For efficiency considerations we first prove that faster-than-quadratic polynomial multiplication algorithms can be performed in linearly homorphic settings. For</p><formula xml:id="formula_9">P ∈ M[X] and C ∈ E[X], we let P ⋉ L C ∈ E[X] be the encrypted polynomial such that L.D sk (P ⋉ L C) = P × L.D sk (C).</formula><p>In the following, we denote by M L (d) the arithmetic cost of a linearly homomorphic product between a clear polynomial and an encrypted one, both of degrees at most d. As an example, the following lemma shows that for any LHE, we can build a Toom-k algorithm for the homomorphic product P ⋉ L C. Similar result can be proved for FFT-based multiplication algorithms, provided the plaintext space contains suitable roots of unity.</p><p>Lemma 4. If T oom k (d) denotes the arithmetic cost of a Toom-k algorithm on polynomials of degree d,</p><formula xml:id="formula_10">M L (d) = O(T oom k (d)). (<label>7</label></formula><formula xml:id="formula_11">)</formula><p>Proof. A Toom-k algorithm basically requires the product of a Vandermonde matrix by a vector for polynomial interpolation and evaluation. To compute a linearly homomorphic product P ⋉ Q where Q is encrypted, we can build a Vandermonde matrix representing the powers of clear evaluation points, and we can consider both P and Q as vectors. The evaluations of P et Q are given by matrix-vector products (in clear and homorphically using (6), resp.). We can perform a clear/encrypted pointwise multiplication on the evaluation vectors with ⋉ L as one vector is in clear. Finally, the interpolation is done by another matrix-vector product between the inverse Vandermonde and the encrypted vector obtained.</p><p>Our algorithms use of the middle product of two polynomials, that we now define. For a polynomial P =</p><formula xml:id="formula_12">d i=0 p i X i ∈ M[X], let ← − P := d i=0 p d−i X i = P ( 1 X )X d be its reverse polynomial, and for a ≤ b ≤ d, let [P ] b a := b i=a p i X i−a . The middle product of two polynomials P = d i=0 p i X i and Q = d ′ i=0 q i X i is defined to be [ ← − P Q] d ′ d = d ′ −d i=0 d j=0 p j q j+i X i . (<label>8</label></formula><formula xml:id="formula_13">)</formula><p>Definition 5. Let (L.Setup, L.E, L.D, + L , ⋉ L ) be a LHE scheme. The linearly homomorphic middle product is an algorithm L.Mid satisfying</p><formula xml:id="formula_14">• C 2 ← L.Mid(P, C 1 ): Given as inputs a clear polynomial P ∈ M[X] and an encrypted polynomial C 1 ∈ E[X], outputs an encrypted polynomial C 2 ∈ E[X].</formula><p>This algorithm satisfies the following correctness property.</p><p>Correctness. For a security parameter κ, for every</p><formula xml:id="formula_15">P 1 , P 2 ∈ M[X],</formula><p>with m and M the minimum and the maximum degrees of those polynomials respectively, and for (pk, sk) ← L.Setup(κ),</p><formula xml:id="formula_16">L.D sk (L.Mid (P 1 , L.E pk (P 2 ))) = ← − P 1 P 2 M m .<label>(9)</label></formula><p>To obtain an algorithm for L.Mid, we rely on Tellegen's transposition principle <ref type="bibr" target="#b1">[Bostan et al.(2003)</ref>]. For, we view the multiplication between P ⋉ L C as a linear map by fixing the clear polynomial P . The transposed of this linear map is exactly the linearly homomorphic middle product, again with the clear polynomial fixed. General results on transposition guarantee that an algorithm for computing P ⋉ L C using t arithmetic operations can be transposed to get an algorithm for L.Mid for polynomials of degree n and n + m, that uses t + n arithmetic operations where n = deg(P ) and m = deg(C). This implies the following lemma. We now turn to one of our main building blocks: multipoint evaluation. Given a degree-d polynomial P and k evaluation points m 1 , . . . , m k , it consists in evaluating P on each m i . The algorithm satisfies the following correctness property.</p><p>Correctness. For a security parameter κ, for every</p><formula xml:id="formula_17">P ∈ M[X], every subset {m 1 , . . . , m k } ⊂ M and (pk, sk) ← L.Setup(κ), if {c 1 , . . . , c k } ← L.MultEv (L.E pk (P ) , {m 1 , . . . , m k }) (10)</formula><p>then, for all i ∈ {1, . . . , k}, Proof. We adapt the algorithm presented in <ref type="bibr" target="#b1">[Bostan et al.(2003)</ref></p><formula xml:id="formula_18">L.D sk (c i ) = P (m i ). (<label>11</label></formula><formula xml:id="formula_19">] to the LHE context. Let C = d−1 i=0 c i X i , P = L.D sk (C)</formula><p>. and m 0 , . . . , m d ∈ M. We assume that d is as power of two to ease the description of the algorithm, but it is not mandatory in practice. The first step of the algorithm consists in computing the following polynomials in clear, for k = 0, . . . , log d and i = 1 . . . , 2 k :</p><formula xml:id="formula_20">P ( i 2 k ) := j∈{ i−1 2 k d+1,..., i 2 k d} (X − m j )<label>(12)</label></formula><p>These polynomials can be computed using a product tree in</p><formula xml:id="formula_21">1 2 M(d) log d + O(d log d) arithmetic operations.</formula><p>Note that these polynomials can be precomputed if the evaluation points are known in advance.</p><p>The algorithm requires then to compute the polynomials</p><formula xml:id="formula_22">B := ←−− P ( 1 1 ) −1 mod X d , and<label>(13)</label></formula><formula xml:id="formula_23">A := ← − B ⋉ L C 2d−1 d−1 . (<label>14</label></formula><formula xml:id="formula_24">) Let A ( 1 1 ) := ← − A .</formula><p>The last step of the algorithm consists in the computation for k = 1, . . . , log d and i = 1, . . . , 2 k of the encrypted polynomials</p><formula xml:id="formula_25">A ( i 2 k ) = L.Mid P i−(−1) (i mod 2) 2 k , A ( ⌈i/2⌉ 2 k−1 ) .<label>(15)</label></formula><p>According to the correctness of the algorithm presented in <ref type="bibr" target="#b1">[Bostan et al.(2003)</ref>],</p><formula xml:id="formula_26">A ( i d ) is an encryption of P (m i ) for 1 ≤ i ≤ d. The final computation of the polynomials A ( i 2 k ) requires M L (d) log d + O(d log d)</formula><p>arithmetic operations, and this dominates the cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Fully homomorphic polynomial arithmetic</head><p>Another building block of our protocol is the computation of a polynomial remainder. This is a harder task in the context of homomorphic encryption. In our case, we divide a clear polynomial by an encrypted one. This computation cannot be performed in a LHE scheme since the divisor and the quotient, both encrypted, need to be multiplied together. Moreover, the need to invert the leading coefficient of the divisor could be a problem. We focus here on the case where the divisor is monic.</p><p>The standard algorithm for this task is the quadratic long division algorithm. This algorithm has a linear multiplicative depth. Below we show how to adapt the fast euclidean division algorithm, based on Newton iteration, to the FHE settings. The algorithm is quasi-linear and has only a logarithmic multiplicative depth.</p><p>To describe it, we need to a polynomial multiplication algorithm in the FHE. We denote by M F (d) the arithmetic cost of a homomorphic product C 1 × F C 2 between two encrypted polynomials of degrees at most d in FHE. The same argument as in the LHE case shows that we can adapt faster-than-quadratic algorithms for polynomial multiplication to the FHE settings, with constant multiplicative depth. Definition 9. Let (F.Setup, F.E, F.D, + F , ⋉ F , × F ) be a FHE scheme. The homomorphic polynomial remainder is an algorithm F.Rem as follows:</p><formula xml:id="formula_27">• C 3 ← F.Rem(C 1 , C 2 ): Given as inputs two encrypted polynomials C 1 , C 2 ∈ E[X], outputs an en- crypted polynomial C 3 ∈ E[X].</formula><p>This algorithm satisfies the following correctness property.</p><p>Correctness. For a security parameter κ, for (pk, sk) ← F.Setup(κ), and for clear polynomials P 1 , P 2 ∈ M[X] such that P 2 is monic,</p><formula xml:id="formula_28">F.D sk (F.Rem (F.E pk (P 1 ) , F.E pk (P 2 ))) = P 1 mod P 2 . (<label>16</label></formula><formula xml:id="formula_29">) Proposition 10. Let C 1 , C 2 ∈ E[X]</formula><p>of respective degrees n and m &lt; n, where C 2 is the encryption of a monic polynomial,</p><formula xml:id="formula_30">F.Rem(C 1 , C 2 ) can be computed in at most 9 2 M F (n − m) + O(n − m) arithmetic operations, with a multiplicative depth O(log(n − m)).</formula><p>Proof. We recall the Netwon-iteration-based algorithm for polynomial euclidean division. We present the fast version based on middle products. The remainder R in the division of A by B, of respective degrees n and m &lt; n, is the unique polynomial satisfying</p><formula xml:id="formula_31">A = BQ + R with deg(R) &lt; m. This implies ← − A = ← − Q ← − B + X n−m+1 ← − R , whence ← − Q = ← − A ← − B −1 mod X n−m+1 . (<label>17</label></formula><formula xml:id="formula_32">)</formula><p>The goal is to homomorphically compute the inverse of ← − B modulo X n−m+1 , using Newton iteration. Let C A and C B be the encryptions of A and B, and 1 be an encryption of 1 with the same public key. The algorithm requires first to compute the t + 1 := ⌈log(n − m + 1)⌉ first polynomials of the sequence (U ):</p><formula xml:id="formula_33">(U ) =    U 0 = 1 U k+1 = U k × F 1 − F ← − C B × F U k 2 k+1 −1 2 k X 2 k mod X 2 k+1</formula><p>Now, instead of computing the last step of the sequence that would give us homomorphically the inverse polynomial of ← − B mod X n−m+1 , we directly compute the quotient, homomorphically. Let U t be the (t + 1) st polynomial of this sequence. We compute</p><formula xml:id="formula_34">S = ← − C A × F U t mod X n−m+1 , and<label>(18)</label></formula><formula xml:id="formula_35">T = ← − C B U t 2 k+1 −1 2 k × F [S] n−m−2 k 0 mod X n−m+1−2 k . (<label>19</label></formula><formula xml:id="formula_36">) Then ← − C Q := S + F T X 2 k is an encryption of ← − Q , the reverse quotient. Finally, we compute C R = C A − F C Q × F C B mod X m<label>(20)</label></formula><p>to get an encryption of the remainder R. Using the fact that M F (2d) ≤ 2M F (d), we can bound the number of arithmetic operations done with that algorithm with 9 2 M F (n − m) + O(n − m). The multiplicative depth is O(t).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Security Model and Assumptions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Security Model</head><p>We are following the definition of security for a two-party protocol presented in <ref type="bibr" target="#b21">[Lindell(2017)</ref>]. Let Π be a two-party protocol computing a polynomial-time functionality f : {0, 1} * × {0, 1} * → {0, 1} * × {0, 1} * , where f = (f 1 , f 2 ). For x and y, inputs of each party, the ideal output-pair is f (x, y) = (f 1 (x, y), f 2 (x, y)) where party i outputs f i (x, y). The view of the i-th party with inputs (x, y) is the tuple</p><formula xml:id="formula_37">view Π i (x, y) := (w, C i , M i ) (<label>21</label></formula><formula xml:id="formula_38">)</formula><p>where w is the i-th party's input, C i regroups all the information generated or computed by the i-th party during the protocol and M i is the content of the messages received by this party during the protocol. The output of the i-th party with inputs (x, y) is denoted output Π i (x, y) and can be computed from view Π i (x, y). The joint output is denoted</p><formula xml:id="formula_39">output Π (x, y) = (output Π 1 (x, y), output Π 2 (x, y))<label>(22)</label></formula><p>Definition 11. Let f = (f 1 , f 2 ) be a functionality. We say that π securely computes f in the presence of honest-but-curious adversaries if there exists a probabilistic polynomial-time algorithms S 1 and S 2 such that for any finite set of inputs I, J ⊂ {0, 1} * :</p><formula xml:id="formula_40">{S 1 (x, f 1 (x, y)), f (x, y)} I,J c ≡ {view Π 1 (x, y), output Π (x, y)} I,J {S 2 (y, f 2 (x, y)), f (x, y)} I,J c ≡ {view Π 2 (x, y), output Π (x, y)} I,J</formula><p>where c ≡ denotes the computational indistinguishability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Unbalanced Private Set Union Scheme</head><p>An unbalanced private set union scheme (UPSU) consists of five algorithms: Setup, Y.Enc, X.ExtractEnc, Comput, Union between a sender S that owns a set Y ⊂ M and a receiver R that owns a set X ⊂ M. </p><formula xml:id="formula_41">E Y ← Y.Enc(Y, keys S ) E X ← X.ExtractEnc(X, keys R , E Y )</formula><p>then the scheme is correct if:</p><formula xml:id="formula_42">Union(X, Y, Comput(E Y , E X , keys S ), keys R ) = X ∪ Y (23)</formula><p>ii) Privacy. The scheme assures privacy of each participant's set if it is secured following Theorem 11 where the definition is instantiated with the PPT functionality</p><formula xml:id="formula_43">f : P(M) × P(M) −→ (P(M) × N) × P(M)<label>(24)</label></formula><p>and for inputs X, Y ⊂ M, the ideal output-pair is</p><formula xml:id="formula_44">f (X, Y) = ((X ∪ Y, |Y|) , ∅)<label>(25)</label></formula><p>iii) Unbalanced efficiency. For a security parameter κ and sets X ⊂ M for the receiver and Y ⊂ M for the sender, if |Y| = o(|X|), then the total communication volume of the scheme, as well as the sender's arithmetic cost, are o(|X|).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Assumptions</head><p>According to <ref type="bibr" target="#b3">[Brakerski et al.(2014)</ref>], the BGV scheme semantic security relies on the general learning with error (GLWE) assumption, which regroups the learning with error (LWE) assumption from <ref type="bibr" target="#b27">[Regev(2009)</ref>] and the ring-LHE (RLWE) assumption from <ref type="bibr" target="#b22">[Lyubashevsky et al.(2013)</ref>].</p><p>Definition 13. (GLWE) For κ a security parameter, n = n(κ) an integer dimension, ϕ d (X) the d th cyclotomic polynomial, with d = d(κ), and p = p(κ)</p><formula xml:id="formula_45">a prime integer. Let R = Z[X] (ϕ d (X)) , R p = R<label>(</label></formula><p>p) and χ = χ(κ) a distribution over R. The GLWE n,ϕ d ,q,χ problem is to distinguish the distribution of (a i , b i ) taken uniformly at random in R n p × R p from the distribution of (a i , b i ) ∈ R n p × R p , where a i and s are taken uniformly at random in R n p , e i is taken following the distribution χ and b i = ⟨a i , s⟩ + e i . The GLWE n,ϕ d ,q,χ assumption is that the GLWE n,ϕ d ,q,χ problem is infeasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Homomorphic UPSU protocol</head><p>The idea of our protocol is to represent each set, the receiver's and the sender's, with polynomials as in <ref type="bibr" target="#b7">[Frikken(2007)</ref>]. We use the euclidean remainder to reduce the receiver's polynomial to the size of the sender's polynomial, and we use efficient multipoint evaluation to alleviate the computational cost of the sender. We perform all those operations under homomorphic schemes to keep the sets private, and with some masking and blending, we obtain our UPSU protocol.</p><p>Remark 14. In the following protocol, we are making the assumption that a LHE and a FHE can share the same plaintext space. We will see in Section 5 that it is obviously true if we are using a FHE scheme for the entire protocol.</p><p>Formally, our protocol is built with the algorithms Setup, Y.Enc, X.ExtractEnc, Comput and Union respectively presented in Algs. 1 to 5. A more visual version is presented in Protocol 1.</p><p>Proposition 15. The protocol built with the algorithms Setup, Y.Enc, X.ExtractEnc, Comput and Union, respectively presented in Algs. 1 to 5, is correct.</p><p>Proof. Correctness. We assume the correctness of the encryption schemes. Let κ be a security parameter, let X be the receiver's set and Y be the sender's set. Let keys R and keys S be the outputs of Setup (κ). We Algorithm 1 Setup(κ) Input: A security parameter κ. Output: A pair of LHE keys (pk R , sk R ) and a FHE public key pk S . Output: A pair of FHE keys (pk S , sk S ) and a LHE public key pk R . Remark: pk R and pk S implicitly define the same plaintext space M but potentially different ciphertext spaces, resp. E L and E F . 2: S: compute P S ← F.E pk S (P S ) and send P S to R; 3: R: return P S ; are using the notations of the algorithms. Let ( c i , c i ′ ) be an element of E ← Comput(Y, { R, H}, keys S ) and let (c i , c ′ i ) be its decrypted tuple with the key sk R . The elements {c ′ i × c −1 i } is added to X if and only if c i is not an encryption of zero. c i is an encryption of r i (a i − b i ) where r i is a non-zero random plaintext, b i is the polynomial R evaluated in y i and a i is the polynomial H evaluated in y i . However, the polynomial R is the sum of H and the euclidean remainder, that we denote S, between P R and P S (that is monic). So a i − b i = R(y i ) − H(y i ) = S(y i ). It means that c i is an encryption of zero if and only if y i is a root of the remainder S and y i ∈ Y is a root of the remainder S if and only if y i ∈ X. It is easy to see that, if</p><formula xml:id="formula_46">c i ̸ = 0, c ′ i × c −1 i = y i .</formula><p>To conclude, the elements added to X are exactly the elements y ∈ Y that are not in X ∩ Y.</p><p>Proposition 16. The protocol built with the algorithms Setup, Y.Enc, X.ExtractEnc, Comput and Union, respectively presented in Algs. 1 to 5, is secure under the honest-but-curious adversary model.</p><p>Proof. The complete simulation proof is presented in Appendix A.1.</p><p>Remark 17. In the following, the communication volume counts the number of ciphertext exchanged, and the arithmetic cost denotes the number of basic arithmetic operations needed in the algorithms. Even if basic homomorphic operations (additions, multiplications, encryption and decryption) are more expensive than clear operations, their computational cost is assumed constant. However, we will still distinguish the cost of polynomials products in clear, in LHE and in FHE as the algorithm used may not be the same (we keep using the notations M, M L and M F ). We will hide the security parameter in that analysis, considering that it is a constant, but all the costs depend on it.</p><p>Proposition 18. For the receiver owning a set X of n elements, and the sender owning a set Y of m elements, with the assumption that n &gt; m, the protocol built with the algorithms Setup, Y.Enc, X.ExtractEnc, Comput and Union, respectively presented in Algs. 1 to 5, computes the set union with the asymptotic complexity bounds presented in Table <ref type="table" target="#tab_4">2</ref>.</p><p>Proof. The Setup algorithm is independent of the size on the sets, and only two keys are exchanged. Y.Enc consists in the computation of P S for S, which costs, with a recursive algorithm, 1 2 M(m) log m basic operations; encrypting the polynomial requires m encryptions, so O(m) computations, and sending this Algorithm 3 X.ExtractEnc(X, keys R , P S ) </p><formula xml:id="formula_47">Input: A set of plaintext X ⊂ M, keys R = {(pk R , sk R ), pk S }</formula><formula xml:id="formula_48">Input: A set of m plaintexts Y ⊂ M, two ciphertext polynomials { R, H} ∈ E F [T ] × E L [T ], and keys S = {(pk S , sk S ), pk R }. Output: A set of ciphertext pairs E ⊂ E L × E L . 1: S: compute R ← F.D sk S ( H) ∈ M[T ]; 2: S: compute {a i } i∈{1,...,m} ← MultEv(R, Y) ⊂ M; 3: S: compute { b i } i∈{1,...,m} ← L.MultEv( H, Y) ⊂ E L ; 4: for all i ∈ {1, . . . , m} do 5: S: randomly select r i $ ← − M \ {0}; 6: S: compute a i ← L.E pk R (a i ) ∈ E L ; 7: S: compute c i ← r i ⋉ L ( a i − L b i ) ∈ E L , c i ′ ← y i ⋉ L c i ∈ E L ; 8: end for 9: S: randomly select π $ ← − S m ; 10: S: compute E ← {( c π(i) , c π(i) ′ )} i∈{1,...,m} ⊂ E L × E L ;</formula><p>11: S: send E to R; 12: R: return E;</p><p>polynomial to R is equivalent to send m ciphertexts. In X.ExtractEnc, R computes P R in 1 2 M(n) log n, and encrypts it in n computations; then, the homomorphic remainder needs Overall, we have shown in Theorem 19 that the protocol summarized in Protocol 1 is a secure unbalanced private set union scheme Theorem 19. The protocol built with the algorithms Setup, Y.Enc, X.ExtractEnc, Comput and Union, respectively presented in Algs. 1 to 5, is a secure unbalanced private set union scheme (UPSU) under the honest-but-curious adversary model.</p><p>Algorithm 5 Union(X, E, keys R ) Input: A set of plaintexts X ⊂ M, a set of ciphertext pairs E ⊂ E L × E L and keys R = {(pk R , sk R ), pk S }. Output: The union set X.</p><formula xml:id="formula_49">1: for ( c i , c i ′ ) ∈ E do 2: R: compute c i ← L.D sk R ( c i ) ∈ M; 3: if c i ̸ = 0 then 4: R: compute c ′ i ← L.D sk R ( c i ′ ) ∈ M; 5: R: compute X ← X ∪ {c ′ i × c −1 i }; 6:</formula><p>end if 7: end for 8: R: return X; </p><formula xml:id="formula_50">1 2 M(m) log m O(m) X.ExtractEnc 9 2 M F (n−m)+ 1 2 M(n) log n + O(n − m) O(1) O(m) Comput O(1) M L (m) log m+ M(m) log m + O(m log m) O(m) Union O(m) O(1) O(1)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Instantiation of LHE and FHE with BGV</head><p>The direct way to instantiate our UPSU Protocol 1 is to use a fully homomorphic encryption scheme for the entire protocol. It avoids any possible conflict of compatibility between the plaintext spaces of LHE and FHE. One of the most efficient FHE encryption scheme available nowadays is the BGV cryptosystem presented in <ref type="bibr" target="#b3">[Brakerski et al.(2014)</ref>], whose security is based on the GLWE assumption. Thanks to Shoup and Halevi, we can use an implementation of the bootstrappable scheme in the C++ open source library HElib<ref type="foot" target="#foot_1">2</ref>  <ref type="bibr" target="#b15">[Halevi and Shoup(2014)</ref>, <ref type="bibr" target="#b16">Halevi and Shoup(2021)</ref>]. Another implementation of the BGV scheme is available in the open-source library Microsoft SEAL<ref type="foot" target="#foot_2">3</ref> . There is also an active research to increase the efficiency of the RLWE based schemes, in particular to speedup the bootstrapping procedure <ref type="bibr" target="#b10">[Geelen and Vercauteren(2023)</ref>, <ref type="bibr" target="#b14">Guimarães et al.(2023)</ref>]. For now, the computation of homomorphic multiplication and the bootstraping procedure are usually quite slow for bootstrappable contexts with decent security. As the research is active on the subject, we expect to have a better efficiency in the future years.</p><p>In the following, we will briefly present the BGV cryptosystem and compare our estimated client (sender) time and communication volume for Protocol 1 to the values presented in <ref type="bibr" target="#b30">[Tu et al.(2023)</ref>, Table <ref type="table" target="#tab_5">3</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">BGV cryptosystem</head><p>We here give an overview of the BGV cryptosystem, and we refer the reader to <ref type="bibr" target="#b3">[Brakerski et al.(2014)</ref>] for more details. First, the plaintext space is a ring R p r =</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Z[X]</head><p>(p r ,ϕ d (X)) where p is a prime number, and ϕ d (X) is the d th cyclotomic polynomial. In this paper, we will always consider r = 1. The ciphertext space is R 2 q where R q = Z[X]</p><p>(q,ϕ d (X)) and q is an odd modulus that might change during computation. The secret key is Protocol 1: Communication optimal UPSU Protocol R S</p><formula xml:id="formula_51">X = {x 1 , ..., xn} ⊂ M Y = {y 1 , ..., ym} ⊂ M Setup {(pk R , sk R ) ← L.Setup(κ), pk S } {(pk S , sk S ) ← F.Setup(κ), pk R } Setup P R ← x i ∈X (T − x i ) P S ← y i ∈Y (T − y i ) P R ← F.E pk S (P R ) P S ← −−−−−−−−−−−−−−−−− − P S ← F.E pk S (P S ) Y.Enc H $ ← − M[T ] m−1 H ← L.E pk R (H) H ← F.E pk S (H) X.ExtractEnc R ← F.Rem( P R , P S ) + F H R, H − −−−−−−−−−−−−−−−−− → R ← F.D sk S ( R) {a i } i∈[m] ← MultEv(R, Y) { b i } i∈[m] ← L.MultEv( H, Y) ∀i ∈ {1, ..., m} : r i $ ← − M \ {0} a i ← L.E pk R (a i ) e i ← r i ⋉ L ( a i − L b i ) e i ′ ← y i ⋉ L e i π $ ← − Sm ∀( e i , e ′ i ) ∈ E E ← −−−−−−−−−−−−−−−−− − E ← {( e π(i) , e π(i) ′ )} Comput e i ← L.D sk R ( e i ) If e i ̸ = 0 : e ′ i ← L.D sk R ( e ′ i ) Union X ← X ∪ {e ′ i × e −1 i } Return X a vector (1, s) ∈ R 2</formula><p>q where s has a small coefficients (usually in {−1, 0, 1}). The public key is basically a two entries matrix A where the first entry is a multiple of the secret key masked with an error term and the second is the opposite of the "multiple" term. An encryption of a plaintext m ∈ R p is then a pair (c 0 , c 1 ) such that c 0 + c 1 s = m + pe mod q, where e is a "small" error term. The decryption of a ciphertext (c 0 , c 1 ) is done with the inner product and the modulus reduction [⟨(1, s), (c 0 , c 1 )⟩] p .</p><p>Having two ciphertexts (c 0 , c 1 ) and (c ′ 0 , c ′ 1 ) such that c 0 +c 1 s = m+pe mod q and c ′ 0 +c ′ 1 s = m ′ +pe ′ mod q, we can see that the ciphertext (c ′′ 0 , c ′′ 1 ) := (c 0 + c ′ 0 , c 1 + c ′ 1 ) satisfies c ′′ 0 + c ′′ 1 s = m + m ′ + pe ′′ mod q so can be decrypted to m+m ′ if the noise e ′′ has a small enough norm. For the same two ciphertexts, if we consider the vector</p><formula xml:id="formula_52">(c ′′ 0 , c ′′ 1 , c ′′ 2 ) = (c 0 c ′ 0 , c 0 c ′ 1 +c 1 c ′ 0 , c 1 c ′ 1 ) = (c 0 , c 1 )⊗(c ′ 0 , c ′ 1 ), we see that c ′′ 0 +c ′′ 1 s+c ′′ 2 s 2 = mm ′ +pe ′′ mod q, with e ′′ = mpe ′ + m ′ pe + ee ′ p 2 .</formula><p>With the help of a procedure called the key switching procedure, one is able to turn the ciphertext (c ′′ 0 , c ′′ 1 , c ′′ 2 ), that can be seen as an encryption under the key (1, s, s 2 ), to a ciphertext (c 0 , c 1 ) such that c 0 + sc 1 = mm ′ + pe ′′ mod q. One more time, if the norm of the noise e ′′ is small enough, this ciphertext can be decrypted to the product mm ′ . We saw that we can perform homomorphic operations with that scheme as long as the noise is controlled, but those operations, in particular the multiplication, add some noise, so this scheme requires a noise management. The first procedure to manage the noise is the modulus switching, which will reduce the modulus q of the ciphertext space and the noise norm proportionally. This first procedure makes this scheme a leveled homomorphic encryption scheme, because after some several such switches, the modulus cannot be reduced anymore. The second procedure, called bootstraping, allows a "reset" of the noise. But this comes with an increase of the ciphertext modulus via an homomorphic decryption. This procedure is more costly, but allows the scheme to be fully homomorphic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experiments</head><p>All our experiments were run a single core of an i7-6700 CPU 3.40GHz.</p><p>The main focus of this paper is a protocol with optimal asymptotic communication volume. In this protocol, the sender computational cost is also independent from the size of the receiver's large set. In this section we provide preliminary estimates on the different practical costs To test the receiver side, we need bootstrappable fully homomorphic modular operations and, up to our knowledge, the HElib library is among the only few that provide this. Unfortunately, for instance, in a bootstrappable context with equivalent security κ = 100, cyclotomic polynomial ϕ d (X) for d = 46235 and plaintext modulus p = 17, a single ciphertext multiplication requires about 0.45 seconds and a single bootstrap, about 8 minutes. Therefore, in order to run the receiver side of our protocol it seems that for now multi-core servers are recommended. Further work is needed to reduce this in practice. It also might be possible to use batching for the polynomial division.</p><p>On the communication and sender sides, however, the situation is more favorable. A trade-off has to be made between fast routines for multi-point evaluation (that have a ciphertext-cleartext multiplicative depth that can be O(log(m)) and naive routines (quadratic time, but of multiplicative depth 1). We here report preliminary results with a naive multi-point evaluation. In order to be able to compare our communication volume with state of the art implementations, we switch to the SEAL library for these tests.</p><p>With a computational security κ = 123.1, and a sender owning a set Y of m = |Y | = 2 10 items of 128 bits, SEAL generates a context with a 20-bits prime, p = 1032193, and can encrypt the m items in two ciphertext matrices, each one containing 4096 slots. For these parameters, SEAL reports that the serialization of one matrix will require 526 449 bits, and as our Protocol 1 requires to exchange 5 times m ciphertexts ( P S , R, H and E, the latter containing 2m ciphertexts), the total communication volume is contained in 10 such ciphertext matrices. This represents 0.628MB overall. Figure <ref type="figure" target="#fig_6">1</ref> compares this with <ref type="bibr" target="#b30">[Tu et al.(2023)</ref>, Table <ref type="table" target="#tab_5">3</ref>] where the memory footprint depends also on n = |X|.  <ref type="table" target="#tab_5">3</ref>] <ref type="bibr" target="#b30">[Tu et al.(2023)</ref>, pub, Table <ref type="table" target="#tab_5">3</ref>] Protocol 1 with SEAL Finally, we provide in Table <ref type="table" target="#tab_5">3</ref> the associated timings for the sender, with m = |Y | = 2 10 , for any n = |X|. In this table, Decryp. is for the decryption of the masked remainder, Clear Eval is for the clear multi-point evaluation of this masked remainder, Hom. Eval is for the multi-point evaluation of the ciphered mask, Filter is for the remaining arithmetic operations of the sender, while Total is the total sender time. In this benchmark we are using a naive algorithm for the multi-point evaluations. These two steps require a quadratic number of operations, while the other two are linear. The cleartext multi-point evaluation is performed fully in clear and is thus much faster than the rest. With the large dimensions, the quadratic behavior starts to show. Then, each homomorphic polynomial evaluation is batched with 4096 slots. Therefore the quadratic behavior does not show in this column: at each evaluation point a single batch is sufficient. Thus, overall, the homomorphic operations are largly dominating. Further, if the sender's set remains in the range of Table <ref type="table" target="#tab_5">3</ref>, its computational effort remains under a minute while exhibiting a linear behavior.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Lemma 6 .</head><label>6</label><figDesc>Let P ∈ M[X] of degree n and C ∈ E[X] of degree n + m. Then L.Mid(P, C) can be computed in M L (max(n, m)) + O(m) operations, with constant multiplicative depth.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 7 .</head><label>7</label><figDesc>Let (L.Setup, L.E, L.D, + L , ⋉ L ) be a LHE scheme. The linearly homomorphic multipoint evaluation is an algorithm L.MultEv such that • {c 1 , . . . , c k } ← L.MultEv(C, {m 1 , . . . , m k }): Given as inputs an encrypted polynomial C ∈ E[X] and a set of k plaintexts m 1 , . . . , m k ∈ M, outputs a set of k ciphertexts c 1 , . . . , c k ∈ E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>) Algorithm L.MultEv can be implemented in O(dk) operations where d = deg(P ), evaluating P on each point with Horner scheme. The multiplicative depth of this algorithm is 1. We now turn to an asymptotically fast algorithm when k = d + 1. Proposition 8. Let C ∈ E[X] of degree d and m 0 , . . . , m d ∈ M be evaluation points. L.MultEv(C, {m 0 , . . . , m d }) can be computed in M L (d) log d + O(d log d) operations, after 1 2 M(d) log d + O(d log d) operations of precomputation on m 0 , . . . , m d . The multiplicative depth of the computation is O(log d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>1: R: compute (pk R , sk R ) ← L.Setup(κ) and send pk R to S; 2: S: compute (pk S , sk S ) ← F.Setup(κ) and send pk S to R; 3: R: return keys R ← {(pk R , sk R ), pk S }; 4: S: return keys S ← {(pk S , sk S ), pk R }; Algorithm 2 Y.Enc(Y, keys S ) Input: A set of plaintext Y ⊂ M and keys S = {(pk S , sk S ), pk R }. Output: An encrypted polynomial P S ∈ E F [T ]. 1: S: compute P ← y∈Y (T − y);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>and a ciphertext polynomial P S . Output: Two encrypted polynomials R ∈ E F [T ] and H ∈ E L [T ] 1: R: compute P R ← x∈X (T − x); 2: R: compute P R ← F.E pk S (P R ); 3: R: randomly select H $ ← − M[T ] such that deg(H) = deg( P S ) − 1; 4: R: compute H ← F.E pk S (H); 5: R: compute H ← L.E pk R (H); 6: R: compute R ← F.Rem( P R , P S ) + F H; 7: R: send { R, H} to S; 8: S: return { R, H}; Algorithm 4 Comput(Y, { R, H}, keys S )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>9 2 M F (n − m) + O(n − m) arithmetic operation as said in Theorem 10; the polynomial encryptions of H and addition with H are in O(m) and the polynomials sent have both degrees m−1, so the communication volume is in O(m). Comput requires m encryptions and decryptions, m homomorphic additions and clear/ciphered products, which are all in O(m); S has to perform a multipoint evaluation both in plaintext and in ciphertext on polynomials of degrees m − 1 in its m elements; the precomputation told in Theorem 8 is already done when computing P S so it adds M L (m) log m + M(m) log m + O(m log m) to the cost; then m pairs of ciphertexts are sent, so a communication volume in O(m). Finally, Union requires at most 2m decryptions and m products and inversions, so O(m) computations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Estimated Memory footprint for m = |Y | = 2 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Protocol Comparison Table: receiver R set size n, sender S set size m, with n ≥ m</figDesc><table><row><cell>Protocol</cell><cell>Frikken</cell><cell>Dav. &amp; Cid.</cell><cell>Zhang et al.</cell><cell>Tu et al.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>outputs a ciphertext c 3 ∈ E. Correctness. For any security parameter κ, (F.Setup, F.E, F.D, + F , ⋉ F ) satisfies the LHE correctness and if (pk, sk) ← F.Setup(κ), for all m 1 , m 2 ∈ M,</figDesc><table><row><cell>i)</cell></row><row><cell>Definition 2. (F.Setup, F.E, F.D, + F , ⋉ F , × F ) is a semantically secure FHE if it satisfies the following</cell></row><row><cell>properties:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Cost analysis of Protocol 1</figDesc><table><row><cell>Algorithm</cell><cell>Ar. Cost for R</cell><cell>Ar. Cost for S</cell><cell>Comm. Vol.</cell></row><row><cell>Setup</cell><cell>O(1)</cell><cell>O(1)</cell><cell>O(1)</cell></row><row><cell>Y.Enc</cell><cell>O(1)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Protocol 1 with SEAL, sender time (seconds)</figDesc><table><row><cell>m = |Y |</cell><cell cols="3">Decryp. Clear Eval. Hom. Eval.</cell><cell>Filter.</cell><cell>Total</cell></row><row><cell>2</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.006</cell><cell>0.012</cell><cell>0.021</cell></row><row><cell>4</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.013</cell><cell>0.024</cell><cell>0.039</cell></row><row><cell>8</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.025</cell><cell>0.048</cell><cell>0.076</cell></row><row><cell>16</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.049</cell><cell>0.096</cell><cell>0.147</cell></row><row><cell>32</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.097</cell><cell>0.191</cell><cell>0.290</cell></row><row><cell>64</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.193</cell><cell>0.379</cell><cell>0.574</cell></row><row><cell>128</cell><cell>0.002</cell><cell>&lt;0.001</cell><cell>0.977</cell><cell>0.756</cell><cell>1.735</cell></row><row><cell>256</cell><cell>0.002</cell><cell>0.001</cell><cell>0.756</cell><cell>1.505</cell><cell>2.263</cell></row><row><cell>512</cell><cell>0.002</cell><cell>0.003</cell><cell>1.498</cell><cell>2.997</cell><cell>4.499</cell></row><row><cell>1024</cell><cell>0.002</cell><cell>0.012</cell><cell>2.980</cell><cell>5.988</cell><cell>8.982</cell></row><row><cell>2048</cell><cell>0.002</cell><cell>0.047</cell><cell cols="3">5.954 11.964 17.966</cell></row><row><cell>4096</cell><cell>0.002</cell><cell>0.186</cell><cell cols="3">11.964 23.938 36.090</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">More generally LHE may be defined over only a group and not a ring, but we need in particular plaintext-ciphertext multiplications over a ring for our application here.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">https://github.com/homenc/HElib</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2">https://github.com/microsoft/SEAL</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Security Proofs</head><p>A.1 Security Proof for Protocol 1</p><p>We assume that both the FHE and LHE schemes used are semantically secure. In the following, we denote the receiver R as the party 1 and the sender S as the party 2 and Protocol 1 will be called Π. This protocol has 3 rounds: R receives 2 messages M 1 and M 3 while S receives only M 2 . The semantic functionality is f : P(M) × P(M) → (P(M) × N) × P(M) where P denotes the power set. The ideal output-pair is</p><p>The following views are reduced to the minimal set that could trivially imply the real view; for example, if the real view have a clear polynomial R, a key pk and a ciphertext F.E pk (R), we omit F.E pk (R) in the view, because if we can simulate both R and pk, it is trivial to simulate F.E pk (R). The views and the outputs of each parties are:</p><p>) where:</p><p>Where S ← F.Rem( P R , P S ) and S is its decryption with the key sk S . The content of the messages are:</p><p>) where:</p><p>On the side of S, a probabilistic polynomial-time algorithm S 2 , taking as input the set Y, should simulate view Π 2 (X, Y) with the following tuple.</p><p>and finally π ′ randomly selected in S |Y| . As in the protocol S is of degree at most |Y| − 1 and H is taken uniformly at random of degree |Y| − 1, one cannot distinguish R = S + H from R 1 , for R 1 taken uniformly at random of size |Y| − 1. This implies also that F.E pk (R 1 ) is a good simulation of R. The set of r ′ i obviously simulates well the set of r i as those are both taken as random non-zero plaintexts. As the encryption schemes are assumed semantically secure, H is indistinguishable from L.E pk ′ (R 2 ) , if R 2 is taken randomly of same degree than H. Finally, we obtain for every subsets X, Y ⊂ M:</p><p>On the side of R, a probabilistic polynomial-time algorithm S 1 taking as input the set X and (X ∪ Y, |Y|) should simulate view Π 1 (X, Y) this way:</p><p>i r</p><p>(2)</p><p>(1) i be random plaintexts in M \ {0} and set the δ others to zero with the indices of the zeroes uniformly distributed. If index i is such that r</p><p>(1) i = 0, then r</p><p>(2) i is taken to be equal to zero too, and for the indices i such that r</p><p>(1) i ̸ = 0, then r</p><p>(2) i is randomly taken in X ∪ Y \ X, with each element in X ∪ Y \ X selected once and only once. From the semantic security of the encryption schemes and the indistinguishability of keys, F.E pk ′ (R 1 ) is indistinguishable from P S . Therefore, this implies that R 3 is indistinguishable from S. Now, H is randomly selected in M[T ] of degree |Y| − 1 in the protocol, it is thus well simulated by R 2 . The set {(r (1) i , r</p><p>(1) i r</p><p>(2) i )} 1≤i≤|Y| contains δ zeroes, and |Y| − δ random pairs, such that the division of the second element of the tuple by the first one gives an element added to X by the protocol: this is thus indistinguishable from r π(i) S(y π(i) ), y π(i) r π(i) S(y π(i) ) 1≤i≤|Y| . Overall we have that an encryption of the first set of pairs under a LHE scheme is a good simulation of the encryption of the second set of pairs under a LHE.</p><p>To conclude, we obtain for every subsets X, Y ⊂ M: {S 1 (X, (X ∪ Y, |Y|)), ((X ∪ Y, |Y|), ∅)} c ≡ {view Π 1 (X, Y), output Π (X, Y)}</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Updatable Private Set Intersection</title>
		<author>
			<persName><surname>Badrinarayanan</surname></persName>
		</author>
		<idno type="DOI">10.2478/POPETS-2022-0051</idno>
		<ptr target="https://doi.org/10.2478/POPETS-2022-0051" />
	</analytic>
	<monogr>
		<title level="j">Proc. Priv. Enhancing Technol</title>
		<imprint>
			<biblScope unit="volume">2022</biblScope>
			<biblScope unit="page" from="378" to="406" />
			<date type="published" when="2022">2022. 2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Bostan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Tellegen&apos;s principle into practice</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Bostan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grégoire</forename><surname>Lecerf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Éric</forename><surname>Schost</surname></persName>
		</author>
		<idno type="DOI">10.1145/860854.860870</idno>
		<ptr target="https://doi.org/10.1145/860854.860870" />
	</analytic>
	<monogr>
		<title level="m">Symbolic and Algebraic Computation, International Symposium ISSAC 2003</title>
				<editor>
			<persName><forename type="first">J</forename><surname>Proceedings</surname></persName>
		</editor>
		<editor>
			<persName><surname>Rafael</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sendra</surname></persName>
		</editor>
		<meeting><address><addrLine>Philadelphia, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003-08-03">2003. August 3-6, 2003</date>
			<biblScope unit="page" from="37" to="44" />
		</imprint>
		<respStmt>
			<orgName>Drexel University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Leveled) Fully Homomorphic Encryption without Bootstrapping</title>
		<author>
			<persName><surname>Brakerski</surname></persName>
		</author>
		<idno type="DOI">10.1145/2633600</idno>
		<ptr target="https://doi.org/10.1145/2633600" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Theory</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">36</biblScope>
			<date type="published" when="2014">2014. 2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Privacy-Preserving Graph Algorithms in the Semi-honest Model</title>
		<author>
			<persName><forename type="first">Shmatikov</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Justin</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vitaly</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2005</title>
				<editor>
			<persName><forename type="first">Bimal</forename><surname>Roy</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Heidelberg</forename><surname>Springer Berlin</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="236" to="252" />
			<pubPlace>Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Efficient Toolkit for Computing Private Set Operations</title>
		<author>
			<persName><forename type="first">Davidson</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Cid</forename><forename type="middle">;</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Cid</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-59870-3_15</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-59870-315" />
	</analytic>
	<monogr>
		<title level="m">Information Security and Privacy -22nd Australasian Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Josef</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Suriadi</forename><surname>Suriadi</surname></persName>
		</editor>
		<meeting><address><addrLine>Auckland, New Zealand</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017-07-03">2017. 2017. 2017. July 3-5, 2017</date>
			<biblScope unit="volume">10343</biblScope>
			<biblScope unit="page" from="261" to="278" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><surname>Frikken</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Privacy-Preserving Set Union</title>
		<author>
			<persName><forename type="first">B</forename><surname>Keith</surname></persName>
		</author>
		<author>
			<persName><surname>Frikken</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-72738-5_16</idno>
		<ptr target="https://doi.org/10.1007/978-3-540-72738-516" />
	</analytic>
	<monogr>
		<title level="m">Applied Cryptography and Network Security, 5th International Conference, ACNS 2007</title>
		<title level="s">Proceedings (Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Moti</forename><surname>Yung</surname></persName>
		</editor>
		<meeting><address><addrLine>Zhuhai, China</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007-06-05">2007. June 5-8, 2007</date>
			<biblScope unit="volume">4521</biblScope>
			<biblScope unit="page" from="237" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Private Set Operations from Oblivious Switching</title>
		<author>
			<persName><surname>Garimella</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-75248-4_21</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-75248-421" />
	</analytic>
	<monogr>
		<title level="m">Public-Key Cryptography -PKC 2021 -24th IACR International Conference on Practice and Theory of Public Key Cryptography, Virtual Event</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2021-05-10">2021. 2021. May 10-13, 2021</date>
			<biblScope unit="volume">12711</biblScope>
			<biblScope unit="page" from="591" to="617" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bootstrapping for BGV and BFV Revisited</title>
		<author>
			<persName><forename type="first">Vercauteren</forename><surname>Geelen</surname></persName>
		</author>
		<idno type="DOI">10.1007/S00145-023-09454-6</idno>
		<ptr target="https://doi.org/10.1007/S00145-023-09454-6" />
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2023">2023. 2023. 2023</date>
		</imprint>
	</monogr>
	<note>Robin Geelen and Frederik Vercauteren</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fully Secure PSI via MPCin-the-Head</title>
		<author>
			<persName><forename type="first">Gordon</forename></persName>
		</author>
		<idno type="DOI">10.56553/POPETS-2022-0073</idno>
		<ptr target="https://doi.org/10.56553/POPETS-2022-0073" />
	</analytic>
	<monogr>
		<title level="j">Proc. Priv. Enhancing Technol</title>
		<imprint>
			<biblScope unit="volume">2022</biblScope>
			<biblScope unit="page" from="291" to="313" />
			<date type="published" when="2022">2022. 2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Groce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Cheaper Private Set Intersection via Differentially Private Leakage</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Rindal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Rosulek</surname></persName>
		</author>
		<idno type="DOI">10.2478/POPETS-2019-0034</idno>
		<ptr target="https://doi.org/10.2478/POPETS-2019-0034" />
	</analytic>
	<monogr>
		<title level="j">Proc. Priv. Enhancing Technol</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="6" to="25" />
			<date type="published" when="2019">2019. 2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Amortized Bootstrapping Revisited: Simpler, Asymptotically-faster</title>
		<author>
			<persName><surname>Guimarães</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2023/014" />
	</analytic>
	<monogr>
		<title level="j">Implemented. IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">14</biblScope>
			<date type="published" when="2023">2023. 2023. 2023. 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Algorithms in HElib</title>
		<author>
			<persName><forename type="first">Shoup</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-44371-2_31</idno>
		<ptr target="https://doi.org/10.1007/978-3-662-44371-231" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2014 -34th Annual Cryptology Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Juan</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Rosario</forename><surname>Gennaro</surname></persName>
		</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014-08-17">2014. 2014. August 17-21, 2014</date>
			<biblScope unit="volume">8616</biblScope>
			<biblScope unit="page" from="554" to="571" />
		</imprint>
	</monogr>
	<note>Proceedings, Part I</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Shai Halevi and Victor Shoup. 2021. Bootstrapping for HElib</title>
		<author>
			<persName><forename type="first">Shoup</forename><surname>Halevi</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00145-020-09368-7</idno>
		<ptr target="https://doi.org/10.1007/s00145-020-09368-7" />
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Private Set Intersection for Unequal Set Sizes with Mobile Applications</title>
		<author>
			<persName><surname>Jia</surname></persName>
		</author>
		<idno type="DOI">10.1515/POPETS-2017-0044</idno>
		<ptr target="https://doi.org/10.1515/POPETS-2017-0044" />
	</analytic>
	<monogr>
		<title level="m">31st USENIX Security Symposium (USENIX Security 22). USENIX Association</title>
				<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-04">2022. 2022. 2017. 2017. 2017, 4 (2017</date>
			<biblScope unit="page" from="177" to="197" />
		</imprint>
	</monogr>
	<note>Shufflebased Private Set Union: Faster and More Secure</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Privacy-Preserving Set Operations</title>
		<author>
			<persName><forename type="first">Song</forename><forename type="middle">;</forename><surname>Kissner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lea</forename><surname>Kissner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2005</title>
				<editor>
			<persName><forename type="first">Victor</forename><surname>Shoup</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg; Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005. 2005</date>
			<biblScope unit="page" from="241" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><surname>Kolesnikov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Scalable Private Set Union from Symmetric-Key Techniques</title>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Rosulek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ni</forename><surname>Trieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-34621-8_23</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-34621-823" />
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2019 -25th International Conference on the Theory and Application of Cryptology and Information Security</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Steven</forename><forename type="middle">D</forename><surname>Galbraith</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Shiho</forename><surname>Moriai</surname></persName>
		</editor>
		<meeting><address><addrLine>Kobe, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019-12-08">2019. December 8-12, 2019</date>
			<biblScope unit="volume">11922</biblScope>
			<biblScope unit="page" from="636" to="666" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">How to Simulate It -A Tutorial on the Simulation Proof Technique</title>
		<author>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><surname>Lindell</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-57048-8_6</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-57048-86" />
	</analytic>
	<monogr>
		<title level="m">Tutorials on the Foundations of Cryptography</title>
				<editor>
			<persName><forename type="first">Yehuda</forename><surname>Lindell</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2017">2017. 2017</date>
			<biblScope unit="page" from="277" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On Ideal Lattices and Learning with Errors over Rings</title>
		<author>
			<persName><surname>Lyubashevsky</surname></persName>
		</author>
		<idno type="DOI">10.1145/2535925</idno>
		<ptr target="https://doi.org/10.1145/2535925" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page">35</biblScope>
			<date type="published" when="2013">2013. 2013. 2013</date>
		</imprint>
	</monogr>
	<note>Vadim Lyubashevsky, Chris Peikert, and Oded Regev</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><surname>Morales</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Private set intersection: A systematic literature review</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Morales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Isaac</forename><surname>Agudo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Lopez</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.cosrev.2023.100567</idno>
		<ptr target="https://doi.org/10.1016/j.cosrev.2023.100567" />
	</analytic>
	<monogr>
		<title level="j">Computer Science Review</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page">100567</biblScope>
			<date type="published" when="2023">2023. 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ramanathan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">BLAG: Improving the Accuracy of Blacklists</title>
		<author>
			<persName><forename type="first">Sivaramakrishnan</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jelena</forename><surname>Mirkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minlan</forename><surname>Yu</surname></persName>
		</author>
		<ptr target="https://www.ndss-symposium.org/ndss-paper/blag-improving-the-accuracy-of-blacklists/" />
	</analytic>
	<monogr>
		<title level="m">27th Annual Network and Distributed System Security Symposium, NDSS 2020</title>
		<title level="s">The Internet Society</title>
		<meeting><address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020-02-23">2020. February 23-26, 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Regev</surname></persName>
		</author>
		<author>
			<persName><surname>Regev</surname></persName>
		</author>
		<idno type="DOI">10.1145/1568318.1568324</idno>
		<ptr target="https://doi.org/10.1145/1568318.1568324" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page">40</biblScope>
			<date type="published" when="2009">2009. 2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">De</forename><surname>Resende</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aranha</forename><surname>Freitas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Faster unbalanced Private Set Intersection in the semi-honest setting</title>
		<author>
			<persName><forename type="first">Amanda</forename><surname>Cristina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davi</forename><surname>Resende</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Freitas</forename><surname>Aranha</surname></persName>
		</author>
		<idno type="DOI">10.1007/S13389-020-00242-7</idno>
		<ptr target="https://doi.org/10.1007/S13389-020-00242-7" />
	</analytic>
	<monogr>
		<title level="j">J. Cryptogr. Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="21" to="38" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Fast Unbalanced Private Set Union from Fully Homomorphic Encryption</title>
		<author>
			<persName><surname>Tu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3576915.3623064</idno>
		<ptr target="https://doi.org/10.1145/3576915.3623064" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security, CCS 2023</title>
				<editor>
			<persName><forename type="first">Weizhi</forename><surname>Meng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Christian</forename><forename type="middle">Damsgaard</forename><surname>Jensen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Cas</forename><surname>Cremers</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</editor>
		<meeting>the 2023 ACM SIGSAC Conference on Computer and Communications Security, CCS 2023<address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2023-11-26">2023. 2023. November 26-30, 2023</date>
			<biblScope unit="page" from="2959" to="2973" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Linear Private Set Union from Multi-Query Reverse Private Membership Test</title>
		<author>
			<persName><forename type="first">Cong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiran</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Min</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongdai</forename><surname>Lin</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/usenixsecurity23/presentation/zhang-cong" />
	</analytic>
	<monogr>
		<title level="m">32nd USENIX Security Symposium, USENIX Security 2023</title>
				<editor>
			<persName><forename type="first">Joseph</forename><forename type="middle">A</forename><surname>Calandrino</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carmela</forename><surname>Troncoso</surname></persName>
		</editor>
		<meeting><address><addrLine>Anaheim, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2023-08-09">2023. August 9-11, 2023</date>
			<biblScope unit="page" from="337" to="354" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
